[ { "title": "RESTful", "url": "/posts/array-vs-linked-list/", "categories": "Blog, Java, RESTful", "tags": "restful java", "date": "2022-09-05 22:55:00 +0900", "snippet": "RESTful? REST란? REpresentational State Transfer)의 약자 REST의 기본 원칙을 지킨 서비스REST의 6가지 원칙 Uniform Interface Stateless Caching Client-Server Layered system Code on demand (optional)Uniform Interface Resource(URI)에 대한 요청을 일관적으로 수행하는 아키텍처 스타일 요청을 하는 Client에 무관 모든 플랫폼에서 요청 가능하며 Loosely Coupling(느슨한 결합)형태를 갖춤Stateless 어떠한 request도 client 상태(state)에 관여하지 않음 즉, 어떤 서버에 요청을 보내든 같은 결과를 얻을 수 있음Caching 이전에 가져온 리소스들을 재사용 GET 메소드에서만 동작Client-Server client는 server에 대해 알 필요 없고, server도 client에 대해 알 필요 없음 (서로 독립적)Layered system 여러 계층으로 구성 클라이언트와 최종 서버사이에 많은 중간 서버들이 존재할 수 있음 중간 서버는 LB를 활성화하고, 공유 캐시를 사용하여 가용성을 향상시킬 수 있음Code on demand (optional) 필요의 경우 client는 server의 코드를 수행할 수 있어야 함RESTful하게 디자인한다는 것은? 리소스(Resource)와 행위(Behavior)를 직관적으로 분리 행위는 HTTP Method로 표현하며, GET, POST, PUT, PATCH, DELETE를 목적에 맞게 사용 메시지(Message)는 Header와 Body를 분리해서 사용 API의 버전을 관리하고, 하위호환성을 보장해야 함 서버와 클라이언트가 같은 방식으로 데이터를 주고 받아야 함(json-json, form-form)RESTful의 장점 멀티플랫폼 지원 가능 원하는 타입으로 데이터를 주고 받음 기존에 사용하던 HTTP를 그대로 사용 가능RESTful의 단점 메소드 갯수가 적음 분산환경에는 적합하지 않음 HTTP 프로토콜만 지원 가능" }, { "title": "Java - Data Structure - Tree", "url": "/posts/java-data-structure-tree/", "categories": "Blog, Java, Data Structure", "tags": "data structure java collections", "date": "2022-08-02 18:10:00 +0900", "snippet": "비선형 자료구조 중 하나이다.계층적 구조를 지니고 있다.Term 노드(node) : 트리에서의 구성 요소 루트(root) : 트리 구조 중 최상위 노드 간선(edge) : 노드와 노드를 연결하는 선 레벨(level) : 트리에서 각각의 층을 나타내는 단어 부모 노드(parent node) : 바로 상위에 존재하는 노드 자식 노드(child node) : 바로 하위에 존재하는 노드 높이(height) : 트리 중 최고 레벨Binary Tree 자식 노드가 최대 2개인 트리 Node 구현 public class Node { private int value; private Node leftNode = null; private Node rightNode = null; public Node(int value) { this.value = value; } public void setValue(int value) { this.value = value; } public void setLeftNode(Node node) { this.leftNode = node; } public void setRightNode(Node node) { this.rightNode = node; } public void getValue() { return this.value; } public Node getLeftNode() { return this.leftNode; } public Node getRightNode() { return this.rightNode; }} Tree 구현 public class Tree { private Node root; public Tree(Node root) { this.root = root; }} Traversal 트리 순회(Tree Traversal)에는 전위 순회(Preorder), 중위 순회(Inorder), 후위 순회(Postorder), 레벨 순서 순회(Level-order)Preorder Traversal 노드 방문 왼쪽 서브 트리를 전위 순회 오른쪽 서브 트리를 전위 순회 깊이 우선 순회(depth-first traversal) public void preorder(Node node) { System.out.println(node.getValue()); if(node.getLeftNode != null) preorder(node.getLeft()); if(node.getRightNode != null) preorder(node.getRight());} Inorder Traversal 왼쪽 서브 트리를 중위 순회 노드 방문 오른쪽 서브 트리를 중위 순회 대칭 순회(symmetric) public void inorder(Node node) { if(node.getLeftNode != null) inorder(node.getLeft()); System.out.println(node.getValue()); if(node.getRightNode != null) inorder(node.getRight());} Postorder Traversal 왼쪽 서브 트리를 후위 순회 오른쪽 서브 트리를 후위 순회 노드 방문 public void postorder(Node node) { if(node.getLeftNode != null) postorder(node.getLeft()); if(node.getRightNode != null) postorder(node.getRight()); System.out.println(node.getValue());} BST(Binary Search Tree)다음과 같은 특징을 가진 트리 각 노드는 중복되지 않는 키로 구성 루트 노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 구성 루트 노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 구성 좌우 서브 트리도 모두 이진 탐색 트리여야 함BST Characteristic 기존 이진 트리보다 빠름 트리의 높이(height)가 h라면, O(h)의 시간복잡도BST Search 루트 노드의 키와 찾고자 하는 키를 비교, 해당 키가 찾는 키라면 탐색을 종료 찾고자 하는 키가 루트 노드의 키보다 작다면 왼쪽 서브 트리 탐색 진행 찾고자 하는 키가 루트 노드의 키보다 크다면 오른쪽 서브 트리 탐색 진행BST Sourcepublic class BinarySearchTree { TreeNode rootNode = null; public void insert(int val) { if(rootNode == null) { rootNode = new TreeNode(val); return; } TreeNode curNode = rootNode; TreeNode parentNode = null; while(curNode != null) { parentNode = curNode; if(curNode.val &amp;gt; val) { curNode = curNode.left; } else if(curNode.val &amp;lt; val) { curNode = curNode.right; } } TreeNode newNode = new TreeNode(val); if(parentNode.val &amp;gt; val) { parentNode.left = newNode; } else if(parentNode.val &amp;lt; val) { parentNode.right = newNode; } } public boolean search(int val) { TreeNode curNode = rootNode; while(curNode != null) { if(curNode.val &amp;gt; val) { curNode = curNode.left; } else if(curNode.val &amp;lt; val) { curNode = curNode.right; } else if(curNode.val == val) { return true; } } return false; }}" }, { "title": "Java - Data Structure", "url": "/posts/java-data-structure/", "categories": "Blog, Java, Data Structure", "tags": "data structure java collections", "date": "2022-08-01 19:39:00 +0900", "snippet": "데이터를 메모리상에서 관리하는 방법들이다.효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다.데이터의 효율적 관리는 수행속도와 관련이 있다.Array 선형으로 데이터를 관리 미리 메모리를 할당 받아 사용 데이터의 물리적 위치와 논리적 위치가 같음LinkedList 선형으로 데이터를 관리 데이터가 추가될 때마다 메모리를 할당 데이터끼리는 주소값으로 연결됨 데이터의 물리적 위치와 논리적 위치가 다를 수 있음Stack 나중에 입력한 데이터가 먼저 출력되는 구조 (Last-In-First-Out)Queue 가장 먼저 입력된 데이터가 먼저 출력 되는 구조 (First-In-First-Out)Tree 부모 노드와 자식 노드간의 연결로 이루어져 있음Heap 최소값과 최대값을 빠르게 찾아내기 위해 완전이진트리 형태로 만들어진 자료구조 우선순위 큐로 구현" }, { "title": "Java - Map", "url": "/posts/java-map/", "categories": "Blog, Java, Data Structure", "tags": "data structure java collections", "date": "2022-07-31 23:12:00 +0900", "snippet": "key와 value를 하나의 쌍으로 저장하는 방식이다.key를 통해 값을 얻는 구조요소의 저장 순서를 유지하지 않는다.key는 중복을 허용하지 않고, value은 중복을 허용한다.HashMap key와 value을 묶어 하나의 entry로 저장 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 매우 빠름 value에 null값도 사용 가능LinkedHashMap HashMap과 동일하지만 요소의 저장 순서를 기억하여 순서를 보장TreeMap 이진 검색 트리(Binary Search Tree)의 형태로 저장 데이터 추가나 제거하는 등의 기본 동작 시간이 매우 빠름 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현PriorityQueue, ArrayDeque 성능 비교   HashMap LinkedHashMap TreeMap get() O(1) O(1) O(log n) containsKey() O(1) O(log n)   next() O(h/n) O(1) O(log n) " }, { "title": "Java Collections - Set", "url": "/posts/java-collections-set/", "categories": "Blog, Java, Data Structure", "tags": "data structure java collections", "date": "2022-07-29 21:49:00 +0900", "snippet": "저장된 값의 순서가 없고, 중복을 허용하지 않는다.HashSet 해쉬 알고리즘을 사용 내부적으로 HashMap 인스턴스를 이용하여 값을 저장LinkedHashSet HashSet의 특징을 그대로 이어받지만, 앞 뒤 요소의 정보를 갖고 있고 순서대로 저장TreeSet 이진 검색 트리(Binary Search Tree)를 사용하여 자료를 관리HashSet, TreeSet 성능 비교   HashSet LinkedHashSet TreeSet add() O(1) O(1) O(h/N) contains() O(1) O(1) O(1) next() O(log n) O(log n) O(log n) " }, { "title": "Java Collections - Queue", "url": "/posts/java-collections-queue/", "categories": "Blog, Java, Data Structure", "tags": "data structure java collections", "date": "2022-07-29 14:20:00 +0900", "snippet": "FIFO(First-In-First-Out) 구조를 가진다.들어올 때는 enqueue, 나갈 때는 dequeue라고 한다.큐는 한쪽 끝을 프론트(front)로 정해서 삭제 연산만 처리하고, 나머지 한쪽은 리어(rear)로 정해서 삽입 연산만 한다.넓이 우선 탐색(BFS)에 사용된다.PriorityQueue 원소에 우선순위를 부여하여 높은 순으로 먼저 반환 이진 트리 구조로 구현ArrayDeque Deque는 양쪽으로 넣고 빼는 것이 가능한 큐PriorityQueue, ArrayDeque 성능 비교   PriorityQueue ArrayDeque offer() O(log n) O(1) peek() O(1) O(1) poll() O(log n) O(1) " }, { "title": "Java Collections - List", "url": "/posts/java-collections-list/", "categories": "Blog, Java, Data Structure", "tags": "data structure java collections", "date": "2022-07-24 19:08:00 +0900", "snippet": "리스트는 객체를 인덱스로 관리하기 때문에 리스트에 객체를 추가하면 인덱스가 자동 부여 된다.리스트는 인터페이스로 되어 있으며 추가(add), 검색(get, contain, size), 삭제(remove, clear)기능의 메서드로 이루어져 있다.값 중복을 허용하는 점이 Set과는 다른 점이다.배열과의 차이는 크기가 동적으로 변한다는 것이다.배열과는 다르게 엘리먼트들 사이에 빈공간을 허용하지 않으며, 중간 객체가 제거되면 해당 객체 인덱스부터 마지막까지 한칸씩 앞으로 이동한다.리스트의 종류에는 ArrayList, Vector, LinkedList가 있다.ArrayList 인덱스를 가지고 있어 검색에 용이 중간 부분 삽입/삭제시 비어있는 부분을 매꾸기 때문에 해당 행위가 빈번할 경우 성능 하락 동기화 보장 xVector 동기화 보장 하나의 스레드가 하나의 자원을 이용하는 경우 오히려 성능 저하 공간이 모자를 경우 공간*2만큼의 공간을 확보하기 때문에 메모리 많이 먹음LinkedList 마지막 노드를 검색하기 위해서는 처음부터 찾아가야 해서 검색에 적합하지 않음 삽입/삭제시 해당 노드 주소만 바꾸면 되기때문에 삽입/삭제가 빈번할 경우 적합ArrayList, Vector, LinkedList 성능 비교   ArrayList Vector LinkedList Thread Safe No Yes No add() O(N) O(N) O(1) get() O(1) O(1) O(N) remove() O(N) O(N) O(1) contains() O(N) O(N) O(N) " }, { "title": "Singleton Pattern", "url": "/posts/singleton-pattern/", "categories": "Blog, Design Pattern", "tags": "design pattern", "date": "2021-12-21 19:08:00 +0900", "snippet": "싱글톤 패턴이란 오직 1개의 인스턴스만 생성하는 패턴이다. 인스턴스를 1개만 생성하는 이유는 불필요한 메모리 누수를 막기 위함이다.해당 클래스의 인스턴스가 필요할 때마다 생성한다면 리소스 소모가 많아지게 되고, 잘못 사용하여 메모리 해제가 되지 않게 된다면메모리 누수로 인해 OOM이 발생하게 된다.상글톤 패턴은 멀티스레드 환경에서 주의해서 사용해야 하는데 그 방법은 다음과 같다.synchronized멀티 스레드 환경에서 thread-safe하게 접근하기 위해서는 인스턴스를 가져오는 메소드에 synchronized 키워드를 붙이면 된다.해당 키워드를 넣으면 먼저 온 스레드가 작업 중인 상태에서 다른 스레드가 접근할 경우 나중에 온 스레드는 대기 상태가 되며, 먼저 온 스레드 작업이 끝나면 다시 시작하게 된다.synchronized키워드를 사용하면 하나의 스레드만 처리가 가능하기 때문에 성능이 떨어진다는 단점이 있어 많이 사용되지는 않고 있다.구현 소스는 다음과 같다.public class Custom { private static Custom custom = null; private Custom() {} public static synchronized Custom getInstance() { if(custom == null) { custom = new Custom(); } return custom; }}double checked locking이 방법은 인스턴스가 null인지 먼저 체크한 후에 synchronized 키워드를 사용하여기존 synchronized의 단점을 어느정도 보완한 방법이다.null체크를 synchronized전과 후 두번 체크한다고 해서 double checkec locking이라 불린다.이 방법을 사용하려면 스레드간 sync가 맞지 않는 것을 방지하기 위해 volatile로 선언해야 한다.하지만 이 방법도 결국 경합이 일어나는 부분에서는 synchronized로 인한 스레드 대기상태가 발생되기 때문에완전한 해결은 아니라 볼 수 있다.구현 소스는 다음과 같다.public class Custom { private static volatile Custom custom = null; private Custom() {} public static Custom getInstance() { if(custom == null) { synchronized(Custom.class) { if(custom == null) { custom = new Custom(); } } } return custom; }}eager initialization처음부터 멤버변수에 인스턴스를 구현 시켜놓는 방법이다.멀티스레드 환경에서 thread-safe하게 동작하면서도 스레드 동작을 제어하지 않아 성능이 떨어지지 않는 장점이 있다.이 방법의 단점은 해당 인스턴스를 사용하든 사용하지 않든 미리 메모리에 올려놓고 있기 때문에메모리가 낭비가 된다는 단점이 있다.구현 소스는 다음과 같다.public class Custom { private static Custom custom = new Custom(); private Custom() {} public static Custom getInstance() { return custom; }}static inner class해당 방법은 클래스 내의 static inner class를 선언하여 eager initialization방법의 단점을 보완한 방법이다.static inner class를 사용할 경우 해당 클래스 로딩시 메모리에 올리는 것이 아니라그 클래스가 실제 사용될 때 메모리에 올려서 사용하게 된다.구현 소스는 다음과 같다.public class Custom { private Custom() {} private static class CustomHolder { private static final Custom INSTANCE = new Custom(); } public static Custom getInstance() { return CustomHolder.INSTANCE; }}" } ]
