<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://juho0719.github.io/</id><title>Juho</title><subtitle>portfolio and blogging page</subtitle> <updated>2022-09-06T22:22:53+09:00</updated> <author> <name>Juho Kim</name> <uri>https://juho0719.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://juho0719.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://juho0719.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Juho Kim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>RESTful</title><link href="https://juho0719.github.io/posts/array-vs-linked-list/" rel="alternate" type="text/html" title="RESTful" /><published>2022-09-05T22:55:00+09:00</published> <updated>2022-09-06T22:22:30+09:00</updated> <id>https://juho0719.github.io/posts/array-vs-linked-list/</id> <content src="https://juho0719.github.io/posts/array-vs-linked-list/" /> <author> <name>Juho Kim</name> </author> <category term="Blog" /> <category term="Java" /> <category term="RESTful" /> <summary> RESTful? REST란? REpresentational State Transfer)의 약자 REST의 기본 원칙을 지킨 서비스 REST의 6가지 원칙 Uniform Interface Stateless Caching Client-Server Layered system Code on demand (optional) Uniform Interface Resource(URI)에 대한 요청을 일관적으로 수행하는 아키텍처 스타일 요청을 하는 Client에 무관 모든 플랫폼에서 요청 가능하며 Loosely Coupling(느슨한 결합)형태를 갖춤 Stateless 어떠한 request도 client 상태(state)에 관여하지 않음 즉, 어떤... </summary> </entry> <entry><title>Java - Data Structure - Tree</title><link href="https://juho0719.github.io/posts/java-data-structure-tree/" rel="alternate" type="text/html" title="Java - Data Structure - Tree" /><published>2022-08-02T18:10:00+09:00</published> <updated>2022-08-13T16:29:36+09:00</updated> <id>https://juho0719.github.io/posts/java-data-structure-tree/</id> <content src="https://juho0719.github.io/posts/java-data-structure-tree/" /> <author> <name>Juho Kim</name> </author> <category term="Blog" /> <category term="Java" /> <category term="Data Structure" /> <summary> 비선형 자료구조 중 하나이다. 계층적 구조를 지니고 있다. Term 노드(node) : 트리에서의 구성 요소 루트(root) : 트리 구조 중 최상위 노드 간선(edge) : 노드와 노드를 연결하는 선 레벨(level) : 트리에서 각각의 층을 나타내는 단어 부모 노드(parent node) : 바로 상위에 존재하는 노드 자식 노드(child node) : 바로 하위에 존재하는 노드 높이(height) : 트리 중 최고 레벨 Binary Tree 자식 노드가 최대 2개인 트리 Node 구현 public class Node { private int value; private Node leftNode = null; private Node ri... </summary> </entry> <entry><title>Java - Data Structure</title><link href="https://juho0719.github.io/posts/java-data-structure/" rel="alternate" type="text/html" title="Java - Data Structure" /><published>2022-08-01T19:39:00+09:00</published> <updated>2022-08-01T19:39:00+09:00</updated> <id>https://juho0719.github.io/posts/java-data-structure/</id> <content src="https://juho0719.github.io/posts/java-data-structure/" /> <author> <name>Juho Kim</name> </author> <category term="Blog" /> <category term="Java" /> <category term="Data Structure" /> <summary> 데이터를 메모리상에서 관리하는 방법들이다. 효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다. 데이터의 효율적 관리는 수행속도와 관련이 있다. Array 선형으로 데이터를 관리 미리 메모리를 할당 받아 사용 데이터의 물리적 위치와 논리적 위치가 같음 LinkedList 선형으로 데이터를 관리 데이터가 추가될 때마다 메모리를 할당 데이터끼리는 주소값으로 연결됨 데이터의 물리적 위치와 논리적 위치가 다를 수 있음 Stack 나중에 입력한 데이터가 먼저 출력되는 구조 (Last-In-First-Out) Queue 가장 먼저 입력된 데이터가 먼저 출력 되는 구조 (First-In-First-Out) Tree 부모 노드와 자식 노드간의... </summary> </entry> <entry><title>Java - Map</title><link href="https://juho0719.github.io/posts/java-map/" rel="alternate" type="text/html" title="Java - Map" /><published>2022-07-31T23:12:00+09:00</published> <updated>2022-07-31T23:12:00+09:00</updated> <id>https://juho0719.github.io/posts/java-map/</id> <content src="https://juho0719.github.io/posts/java-map/" /> <author> <name>Juho Kim</name> </author> <category term="Blog" /> <category term="Java" /> <category term="Data Structure" /> <summary> key와 value를 하나의 쌍으로 저장하는 방식이다. key를 통해 값을 얻는 구조 요소의 저장 순서를 유지하지 않는다. key는 중복을 허용하지 않고, value은 중복을 허용한다. HashMap key와 value을 묶어 하나의 entry로 저장 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 매우 빠름 value에 null값도 사용 가능 LinkedHashMap HashMap과 동일하지만 요소의 저장 순서를 기억하여 순서를 보장 TreeMap 이진 검색 트리(Binary Search Tree)의 형태로 저장 데이터 추가나 제거하는 등의 기본 동작 시간이 매우 빠름 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능... </summary> </entry> <entry><title>Java Collections - Set</title><link href="https://juho0719.github.io/posts/java-collections-set/" rel="alternate" type="text/html" title="Java Collections - Set" /><published>2022-07-29T21:49:00+09:00</published> <updated>2022-07-29T21:49:00+09:00</updated> <id>https://juho0719.github.io/posts/java-collections-set/</id> <content src="https://juho0719.github.io/posts/java-collections-set/" /> <author> <name>Juho Kim</name> </author> <category term="Blog" /> <category term="Java" /> <category term="Data Structure" /> <summary> 저장된 값의 순서가 없고, 중복을 허용하지 않는다. HashSet 해쉬 알고리즘을 사용 내부적으로 HashMap 인스턴스를 이용하여 값을 저장 LinkedHashSet HashSet의 특징을 그대로 이어받지만, 앞 뒤 요소의 정보를 갖고 있고 순서대로 저장 TreeSet 이진 검색 트리(Binary Search Tree)를 사용하여 자료를 관리 HashSet, TreeSet 성능 비교   HashSet LinkedHashSet TreeSet add() O(1) O(1) O(h/N) contains() ... </summary> </entry> </feed>
